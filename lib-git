#!/bin/bash
# TODO: gids for commit - last ~1 ~2
# get all branches from remote (after clone)

UTILS_GIT_TRACE=0
alias log_print='[ "$UTILS_GIT_TRACE" == "1" ] && echo -e 1>&2 '

tab="%x09"
git_red="%C(red)" # "%x1b[31m"
git_green="%C(green)" #"x1b[32m"
git_green_dim="%C(green dim)"
git_green_bold="%C(green bold)"
git_norm="%x1b[0m"
git_blue="%C(blue)" #"%x1b[33m%x1b[34m%x1b[40m"
git_yellow="%C(yellow)"
#git_white="%C(reset)"
git_white="%C(white)" # bold
git_grey="%C(dim white)"
#    current = yellow reverse
#  [color "diff"]
    #meta = yellow bold
    #frag = magenta bold
    #old = red bold
    #new = green bold
HASH=%h
COMMIT="%s" #text
TIME="%ad%x08%x08%x08%x08%x08%x08%x08%x08%x08" # backspace timezone 
TIME2="(%ar)"
#BRANCH="%d"
AUTHOR="%an"
REFNAME="%d"

find_branch() {
	local mask=$1
	#local __result_varname=$2
	
	# find all by <mask>*
	local find_res=$(git branch 2> /dev/null | sed -e 's/^* \(.*\)/\1/' -e 's/  \(.*\)/\1/' | grep "^$mask")
	#echo find_res1: $find_res 1>&2
	local cn=$[$(echo "$find_res" | wc -l)] # found count
	#echo cn: $cn 1>&2
	[[ $cn -gt 1 ]] && echo "Branch containing $mask\* - IS AMBIGUOUS. Found $cn:" $find_res 1>&2 && exit 1 #echo "$find_res" 1>&2 && 
	
	if [[ "$find_res" != "" ]]; then 
		__result=$find_res
	  else # if not found at all
		# find all by *<mask>*
		local find_res=$(git branch 2> /dev/null | sed -e 's/^* \(.*\)/\1/' -e 's/  \(.*\)/\1/' | grep "$mask") 
		#echo find_res2: $find_res 1>&2
		[[ "$find_res" == "" ]] && echo "Branch containing $mask - NOT FOUND " 1>&2 && exit 2 
		#echo find_res:"$find_res"
		cn=$[$(echo "$find_res" | wc -l)] # found count
		[[ $cn > 1 ]] && echo "Branch containing $mask - IS AMBIGUOUS. Found $cn:" $find_res 1>&2 && exit 3 #echo "$find_res" 1>&2 && 
		__result=$find_res
  	  fi
  	echo $__result
  	#local myresult="$__result"
  	#echo myresult: $myresult
  	#eval $__result="'$myresult'"
	}

current_branch() {
	#echo $(git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
	curr_branch=`echo $(git rev-parse --abbrev-ref HEAD 2> /dev/null)`
	#[[ "$curr_branch" != "" ]] && curr_branch=" $curr_branch"
	echo "$curr_branch"
	}
branch_for_ps1(){
	curr_branch=$(current_branch)
	[[ "$curr_branch" != "" ]] && curr_branch=" $curr_branch"
	echo "$curr_branch"
	}
# last tag - git describe --always --tag
	# full - git log -1 --format="%H%n%aD"

current_remote() {
	curr_branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null) #имя ветки, в которую был внесен последний коммит
	#git rev-parse <revision> - возвращает хеш коммита для указанной ревизии. Например, git rev-parse HEAD вернет хеш коммита, на который указывает HEAD.
	#echo curr_branch: $curr_branch 1>&2
	if [[ "$curr_branch" != "" ]]; then
		#echo "[current_remote]curr_branch NOT FOUND" 1>&2 && return
	  #else
		remotes=$(git config branch.$curr_branch.remote 2> /dev/null)
		if [[ "$remotes" == "" ]]; then
			remotes=$(git remote show)
			#echo "[current_remote] remotes: $remotes" 1>&2
			local cn=$[$(echo "$remotes" | wc -l)]
			[[ $cn -eq 1 ]] && echo "$remotes" && return
		  else
		  	echo "$remotes"
		  fi
	  fi	
	}
remote_for_ps1(){
	curr_remote=$(current_remote)
	[[ "$curr_remote" != "" ]] && curr_remote="->$curr_remote [$(get_remote_repo_name)] "
	echo "$curr_remote"
	}

curr_merge_branch() {
	curr_branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
	[[ "$curr_branch" == "" ]] && echo curr_branch NOT FOUND 1>&2 && return
	echo $(git config branch.$curr_branch.merge 2> /dev/null | cut -d / -f 3)
	}


ahead_behind() {
	curr_branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
	[[ "$curr_branch" == "" ]] && return #&& echo "[ahead_behind] curr_branch NOT FOUND" 1>&2 
	curr_remote=$(current_remote)
	[[ "$curr_remote" == "" ]] && echo -e "${red}[ahead_behind] curr_remote NOT FOUND$norm" 1>&2 && return
	curr_merge_branch=$(git config branch.$curr_branch.merge 2> /dev/null | cut -d / -f 3)
	if [[ "$curr_merge_branch" == "" ]]; then
		echo -e "${red}[ahead_behind] curr_merge_branch NOT FOUND$norm" 1>&2 #&& return
		curr_merge_branch=$curr_branch
	  fi
	#git remote update (git remote -v update
	#git status -uno
	git fetch
	res=$(git rev-list --left-right --count $curr_branch...$curr_remote/$curr_merge_branch 2> /dev/null) #| tr -s '\t' "|\${red}"
	arr=($(echo $res))
	#echo ${#arr[*]} 1>&2
	#echo ${arr[1]} 1>&2
	[ ${arr[0]} -ne 0 ] && ahead="$green+${arr[0]}$norm"
	[ ${arr[0]} -eq 0 ] && ahead="$cyan_dim${arr[0]}$norm"
	[ ${arr[1]} -ne 0 ] && behind="$red-${arr[1]}$norm"
	[ ${arr[1]} -eq 0 ] && behind="$cyan_dim${arr[1]}$norm"
	echo -e "$ahead$cyan_dim:$norm$behind"
	#↑n: ahead of remote by n commits
	#↓n: behind remote by n commits
	#L local branch, not remotely tracked
	}

files_status () {
	local all=$(git status -s --untracked-files --porcelain 2> /dev/null) 
	#local total=$(echo "$all"| wc -l)
	#echo total: $total 1>&2

	local untracked=$(echo "$all"| grep -E "^\?\?" | wc -l)
	untracked=`echo $untracked`
	#echo "untracked:-$untracked" 1>&2
	
	local staged=$(echo "$all" | grep "^[ADM]" | wc -l) # git status -s --untracked-files --porcelain | grep "^(A|D|M)"
	staged=`echo $staged`
	#echo staged: $staged 1>&2
	
	local changed=$(echo "$all"| grep -E "^.{0,1}M" | wc -l) # but unstaged
	changed=`echo $changed`
	#echo changed: $changed 1>&2
	
	local deleted=$(echo "$all"| grep -E "^.{0,1}D" | wc -l)
	deleted=`echo $deleted`
	#echo deleted: $deleted 1>&2
	
	#local ignored=$(git status -s --ignored --porcelain 2> /dev/null)
	#ignored=$(echo "$ignored"| grep "^!!" | wc -l)
	#ignored=`echo $ignored`
	#echo ignored: $ignored 1>&2
	# ✭ / * : Untracked
	# ✹ / ~ : Modified in the working tree
	# ✚ / + : Staged in the index (Exclude Renamed status)
	# ➜ / » : Renamed
	# ═ / = : Unmerged
	# ✖ / - : Deleted (This indicator can't be shown, as NERDTree doesn't display deleted files. I have no prefect idea to solve this problem currently.)
	# ✗ / × : Dirty (Only for directory)
	# ✔ / ø : Clean (Only for root directory)
	#✔: repository clean
		#●n: there are n staged files
	#✖n: there are n files with merge conflicts
		#✚n: there are n changed but unstaged files
	#…n: there are n untracked files
	#⚑n: there are n stash entries
	modi=$(( $staged + $changed )) # + $untracked + $deleted
	#echo modi: $modi 1>&2
	local res
	if [[ $modi -gt 0 || $untracked -gt 0 || $deleted -gt 0 ]]; then
		#[[ $modi -gt 0 ]] && res=$res$(echo -e "${green}~$modi") #✚
		#res="$res$norm"
		[[ $staged -gt 0 ]] && res=$res$(echo "\$green+$staged ") #✚
		#res="$res$norm"

		[[ $changed -gt 0 ]] && res=$res$(echo "\$yellow_bright~$changed ") #✚
		#[[ $changed -gt 0 ]] && res=$res$(echo -e "${yellow}=$changed$norm") #✚
		#res="$res$norm"

		[[ $deleted -gt 0 ]] && res=$res$(echo "\$red-$deleted ") #✖
		#res="$res$norm"

		[[ $untracked -gt 0 ]] && res=$res$(echo "\$red_bright?$untracked ") #…
		#res="$res$norm"

		#[[ $ignored -gt 0 ]] && res=$res$(echo -e "${grey} !$ignored") #…
		res="$res\$norm "
		echo "$res"
	  fi
	}

git_staged(){
	local all=$(git status -s --untracked-files --porcelain 2> /dev/null) 
	local staged=$(echo "$all" | grep "^[ADM]" | wc -l) # git status -s --untracked-files --porcelain | grep "^(A|D|M)"
	staged=`echo $staged`
	[[ $staged -gt 0 ]] && staged="+$staged "
	[[ $staged -eq 0 ]] && staged=""
	echo "$staged"
	}
git_changed(){
	local changed=$(git status -s --untracked-files --porcelain 2> /dev/null | grep -E "^\?\?|.{0,1}M" | wc -l) # but unstaged
	changed=`echo $changed`
	[[ $changed -gt 0 ]] && changed="~$changed "
	[[ $changed -eq 0 ]] && changed=""
	echo "$changed"
	}
git_deleted(){
	local all=$(git status -s --untracked-files --porcelain 2> /dev/null) 
	local deleted=$(echo "$all"| grep -E "^.{0,1}D" | wc -l)
	deleted=`echo $deleted`
	[[ $deleted -gt 0 ]] && deleted="-$deleted "
	[[ $deleted -eq 0 ]] && deleted=""
	echo "$deleted"
	}

git_prompt(){

	#[[ "$curr_branch" != "" ]] && echo -e " $green[$green $curr_branch$magenta->$(current_remote)$cyan_bold$(files_status)$green ]$norm " #$green_dim$
	[[ "$curr_branch" != "" ]] && echo "$cyan_back \w $norm $green$curr_branch$magenta->$(current_remote) $cyan_bold$green+$staged$red-$deleted$norm$cyan_back > $norm " #$green

	#[[ "$curr_branch" != "" ]] && echo "$green $curr_branch$magenta-> $cyan_bold$(files_status)$norm" 
	}
compare_with_remote(){
	#curr_remote=$(current_remote)
	LOCAL=$(git rev-parse @)
	#REMOTE=$(git rev-parse @{u}) # from local
	REMOTE=$(git ls-remote 2>/dev/null | awk "/HEAD/ {print \$1}")
	BASE=$(git merge-base @ @{u})
	#echo LOCAL:$LOCAL REMOTE:$REMOTE BASE:$BASE
	if [ $LOCAL = $REMOTE ]; then
		true #echo "Up-to-date"
	  elif [ $LOCAL = $BASE ]; then
		echo -e "${yellow}NEED TO PULL !${norm}" 1>&2
	  elif [ $REMOTE = $BASE ]; then
		echo -e "${yellow}NEED TO PUSH !${norm}" 1>&2
	  else
		echo -e "${red_bright}DIVERGED !!${norm}" 1>&2
	  fi
		}

git_rebase_status(){
	git status | head -n 1 # rebase in progress; onto 0103a6e
	}
get_remote_repo_name(){
	git config --get remote.$(current_remote).url | sed -E 's|.*/(.*).git/?$|\1|'	
	}

renametab() {
	# todo: oldpwd for *nix (~/.oldpwd for msys only)
	[[ "$(cat ~/.oldpwd)" == "$(pwd)" ]] && exit
	#echo "-$(pwd)-" 1>&2
	#echo "=$OLDPWD="  1>&2
	#echo "rename tab" 1>&2
	if [ "$ConEmuPID" != "" ]; then $ConEmuBaseDir/ConEmuC -GuiMacro Rename 0 "${PWD##*/}" 1> /dev/null; fi
	if [ "$TERM_PROGRAM" == "Apple_Terminal" ]; then echo -ne "\033]0;${PWD##*/}\007"; fi
	pwd > ~/.oldpwd
	#PREV_TAB="${PWD##*/}"
}

#http://mediadoneright.com/content/ultimate-git-ps1-bash-prompt
#export PS1="\\033[0;34;48m[\u / \h] \\033[0;32;49m\w$git_branch: \[\033[m\]" #\\033[0;33;49m
#parse_git_branch() { git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/' }

GIT_PROMPT="\[$cyan_back\] \w \[$norm\]\[$green\]\$(branch_for_ps1)\[$magenta\]\$(remote_for_ps1)\[$cyan_bold\]\[$yellow\]\$(git_changed)\[$green\]\$(git_staged)\[$red\]\$(git_deleted)\[$norm\] \[$cyan_back\] \t > \[$norm\] \$(renametab)" 
#\[<color>\] чтобу у bash'а не ехала крыша при определении длины промпта и текст командной строки не "съезжал" на следующую строку.
