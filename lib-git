#!/bin/bash
# TODO: gids for commit - last ~1 ~2
# get all branches from remote (after clone)

UTILS_GIT_TRACE=0
UTILS_GIT_THE_OS=$(uname -s)
UTILS_GIT_INCLUDE="utils-git-include"
UTILS_GIT_ALIASES="utils-git-aliases"
case "$UTILS_GIT_THE_OS" in
	MINGW*)
		UTILS_GIT_TIMESTAMP=`stat -c %y $HOME_UTILS_GIT/lib-git`
		UTILS_GIT_ALIAS_TIMESTAMP=`stat -c %y $HOME/.utils-git/$UTILS_GIT_ALIASES`
		alias sed='sed'
		# UTILS_GIT_SED="sed"
		;;
	Darwin)
		UTILS_GIT_TIMESTAMP=`stat -f "%Sm" -t "%F %T" $HOME_UTILS_GIT/lib-git`
		UTILS_GIT_ALIAS_TIMESTAMP=`stat -f "%Sm" -t "%F %T" "$HOME/.utils-git/$UTILS_GIT_ALIASES"`
		# UTILS_GIT_SED="gsed"
		alias sed='gsed'
		;;
	# linux??)
		# UTILS_PRJ_SED_BACKUP=??
		# UTILS_PRJ_TIMESTAMP=??
	*)
		# fail !
  esac

alias log_print='[ "$UTILS_GIT_TRACE" == "1" ] && echo -e 1>&2 '
alias error='cmd_utils_git_error'
alias notice='cmd_utils_git_notice'
alias result='cmd_utils_git_result'

tab="%x09"
git_red="%C(red)" # "%x1b[31m"
git_green="%C(green)" #"x1b[32m"
git_green_dim="%C(green dim)"
git_green_bold="%C(green bold)"
git_norm="%x1b[0m"
git_blue="%C(blue)" #"%x1b[33m%x1b[34m%x1b[40m"
git_yellow="%C(yellow)"
#git_white="%C(reset)"
git_white="%C(white)" # bold
git_grey="%C(dim white)"
#    current = yellow reverse
#  [color "diff"]
    #meta = yellow bold
    #frag = magenta bold
    #old = red bold
    #new = green bold
HASH=%h
COMMIT="%s" #text
TIME="%ad%x08%x08%x08%x08%x08%x08%x08%x08%x08" # backspace timezone 
TIME2="(%ar)"
#BRANCH="%d"
AUTHOR="%an"
REFNAME="%d"

function cmd_utils_git_wrapper(){
	local cmd_one="$1"
	local utils_git_timestamp_current
	#echo "UTILS_GIT_TRACE: $UTILS_GIT_TRACE"
	case "$UTILS_GIT_THE_OS" in
		MINGW*)
			utils_git_timestamp_current=`stat -c %y $HOME_UTILS_GIT/lib-git`
			utils_git_alias_timestamp_current=`stat -c %y $HOME/.utils-git/$UTILS_GIT_ALIASES`
			;;
		Darwin)
			utils_git_timestamp_current=`stat -f "%Sm" -t "%F %T" $HOME_UTILS_GIT/lib-git`
			utils_git_alias_timestamp_current=`stat -f "%Sm" -t "%F %T" "$HOME/.utils-git/$UTILS_GIT_ALIASES"`
			;;
		# linux??)
			# UTILS_GIT_TIMESTAMP=??
		*)
			# fail !
	  esac
	[ "$utils_git_timestamp_current" != "$UTILS_GIT_TIMESTAMP" ] && echo "Updating commands..." && source "$HOME_UTILS_GIT/lib-git"
	[ "$utils_git_alias_timestamp_current" != "$UTILS_GIT_ALIAS_TIMESTAMP" ] && echo "Updating aliases..." && source "$HOME/.utils-git/$UTILS_GIT_ALIASES"

	log_print "UTILS_GIT_TIMESTAMP:               $UTILS_GIT_TIMESTAMP"
	log_print "utils_git_timestamp_current:       $utils_git_timestamp_current"
	log_print "UTILS_GIT_ALIAS_TIMESTAMP:         $UTILS_GIT_ALIAS_TIMESTAMP"
	log_print "utils_git_alias_timestamp_current: $utils_git_alias_timestamp_current"
	shift
	local params
	while :
	do
		#log_print "arg: $1"
		case "$1" in
			#-h|--help) ;;
			-v) UTILS_GIT_TRACE=1 ;;
			#-*) echo "invalid argument $1";;
			?*) params="$params $1" ;;
			"") break ;;
		  esac
		shift
	done
	log_print "cmd:     $cmd_one"
	log_print "params: $params"
	eval $cmd_one "$params" #"$@*"
	UTILS_GIT_TRACE=0
	}

function cmd_utils_git_error(){
	msg="$*"
	#log_print "msg: $msg"
	echo -e "${red_back}$msg${norm}"
	}
function cmd_utils_git_notice(){
	msg="$*"
	#log_print "msg: $msg"
	echo -e "${cyan}$msg ${norm}"
	}
function cmd_utils_git_result(){
	msg="$*"
	#log_print "msg: $msg"
	echo -e "${green}$msg${norm}"
	}

function find_branch() {
	local mask=$1
	#local __result_varname=$2
	
	# find all by <mask>*
	local find_res=$(git branch 2> /dev/null | sed -e 's/^* \(.*\)/\1/' -e 's/  \(.*\)/\1/' | grep "^$mask")
	#echo find_res1: $find_res 1>&2
	local cn=$[$(echo "$find_res" | wc -l)] # found count
	#echo cn: $cn 1>&2
	[[ $cn -gt 1 ]] && echo "Branch containing $mask\* - IS AMBIGUOUS. Found $cn:" $find_res 1>&2 && return 1 #echo "$find_res" 1>&2 && 
	
	if [[ "$find_res" != "" ]]; then 
		__result=$find_res
	  else # if not found at all
		# find all by *<mask>*
		local find_res=$(git branch 2> /dev/null | sed -e 's/^* \(.*\)/\1/' -e 's/  \(.*\)/\1/' | grep "$mask") 
		#echo find_res2: $find_res 1>&2
		[[ "$find_res" == "" ]] && echo "Branch containing $mask - NOT FOUND " 1>&2 && return 2 
		#echo find_res:"$find_res"
		cn=$[$(echo "$find_res" | wc -l)] # found count
		[[ $cn > 1 ]] && echo "Branch containing $mask - IS AMBIGUOUS. Found $cn:" $find_res 1>&2 && return 3 #echo "$find_res" 1>&2 && 
		__result=$find_res
  	  fi
  	echo $__result
  	#local myresult="$__result"
  	#echo myresult: $myresult
  	#eval $__result="'$myresult'"
	}
function find_remote() {
	local mask=$1
	local find_res=$(git remote show 2> /dev/null | grep "^$mask")
	log_print "find_res: $find_res"
	return
	local cn=$[$(echo "$find_res" | wc -l)] # found count
	#echo cn: $cn 1>&2
	[[ $cn -gt 1 ]] && echo "Branch containing $mask\* - IS AMBIGUOUS. Found $cn:" $find_res 1>&2 && return 1 #echo "$find_res" 1>&2 && 
	
	if [[ "$find_res" != "" ]]; then 
		__result=$find_res
	  else # if not found at all
		# find all by *<mask>*
		local find_res=$(git branch 2> /dev/null | sed -e 's/^* \(.*\)/\1/' -e 's/  \(.*\)/\1/' | grep "$mask") 
		#echo find_res2: $find_res 1>&2
		[[ "$find_res" == "" ]] && echo "Branch containing $mask - NOT FOUND " 1>&2 && return 2 
		#echo find_res:"$find_res"
		cn=$[$(echo "$find_res" | wc -l)] # found count
		[[ $cn > 1 ]] && echo "Branch containing $mask - IS AMBIGUOUS. Found $cn:" $find_res 1>&2 && return 3 #echo "$find_res" 1>&2 && 
		__result=$find_res
  	  fi
  	echo $__result
  	#local myresult="$__result"
  	#echo myresult: $myresult
  	#eval $__result="'$myresult'"
	}
function current_branch() {
	#echo $(git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
	curr_branch=`echo $(git rev-parse --abbrev-ref HEAD 2> /dev/null)`
	#[[ "$curr_branch" != "" ]] && curr_branch=" $curr_branch"
	echo "$curr_branch"
	}
# last tag - git describe --always --tag
	# full - git log -1 --format="%H%n%aD"
function current_remote() {
	curr_branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null) #имя ветки, в которую был внесен последний коммит
	#git rev-parse <revision> - возвращает хеш коммита для указанной ревизии. Например, git rev-parse HEAD вернет хеш коммита, на который указывает HEAD.
	#echo curr_branch: $curr_branch 1>&2
	if [[ "$curr_branch" != "" ]]; then
		#echo "[current_remote]curr_branch NOT FOUND" 1>&2 && return
	  #else
		remotes=$(git config branch.$curr_branch.remote 2> /dev/null)
		if [[ "$remotes" == "" ]]; then
			remotes=$(git remote show)
			#echo "[current_remote] remotes: $remotes" 1>&2
			local cn=$[$(echo "$remotes" | wc -l)]
			[[ $cn -eq 1 ]] && echo "$remotes" && return
		  else
		  	echo "$remotes"
		  fi
	  fi	
	}
function curr_merge_branch() {
	curr_branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
	[[ "$curr_branch" == "" ]] && echo curr_branch NOT FOUND 1>&2 && return
	echo $(git config branch.$curr_branch.merge 2> /dev/null | cut -d / -f 3)
	}

function ahead_behind() {
	curr_branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
	[[ "$curr_branch" == "" ]] && return #&& echo "[ahead_behind] curr_branch NOT FOUND" 1>&2 
	curr_remote=$(current_remote)
	[[ "$curr_remote" == "" ]] && echo -e "${red}[ahead_behind] curr_remote NOT FOUND$norm" 1>&2 && return
	curr_merge_branch=$(git config branch.$curr_branch.merge 2> /dev/null | cut -d / -f 3)
	if [[ "$curr_merge_branch" == "" ]]; then
		echo -e "${red}[ahead_behind] curr_merge_branch NOT FOUND$norm" 1>&2 #&& return
		curr_merge_branch=$curr_branch
	  fi
	#git remote update (git remote -v update
	#git status -uno
	git fetch
	res=$(git rev-list --left-right --count $curr_branch...$curr_remote/$curr_merge_branch 2> /dev/null) #| tr -s '\t' "|\${red}"
	arr=($(echo $res))
	#echo ${#arr[*]} 1>&2
	#echo ${arr[1]} 1>&2
	[ ${arr[0]} -ne 0 ] && ahead="$green+${arr[0]}$norm"
	[ ${arr[0]} -eq 0 ] && ahead="$cyan_dim${arr[0]}$norm"
	[ ${arr[1]} -ne 0 ] && behind="$red-${arr[1]}$norm"
	[ ${arr[1]} -eq 0 ] && behind="$cyan_dim${arr[1]}$norm"
	echo -e "$ahead$cyan_dim:$norm$behind"
	#↑n: ahead of remote by n commits
	#↓n: behind remote by n commits
	#L local branch, not remotely tracked
	}
function files_status () {
	local all=$(git status -s --untracked-files --porcelain 2> /dev/null) 
	#local total=$(echo "$all"| wc -l)
	#echo total: $total 1>&2

	local untracked=$(echo "$all"| grep -E "^\?\?" | wc -l)
	untracked=`echo $untracked`
	#echo "untracked:-$untracked" 1>&2
	
	local staged=$(echo "$all" | grep "^[ADM]" | wc -l) # git status -s --untracked-files --porcelain | grep "^(A|D|M)"
	staged=`echo $staged`
	#echo staged: $staged 1>&2
	
	local changed=$(echo "$all"| grep -E "^.{0,1}M" | wc -l) # but unstaged
	changed=`echo $changed`
	#echo changed: $changed 1>&2
	
	local deleted=$(echo "$all"| grep -E "^.{0,1}D" | wc -l)
	deleted=`echo $deleted`
	#echo deleted: $deleted 1>&2
	
	#local ignored=$(git status -s --ignored --porcelain 2> /dev/null)
	#ignored=$(echo "$ignored"| grep "^!!" | wc -l)
	#ignored=`echo $ignored`
	#echo ignored: $ignored 1>&2
	# ✭ / * : Untracked
	# ✹ / ~ : Modified in the working tree
	# ✚ / + : Staged in the index (Exclude Renamed status)
	# ➜ / » : Renamed
	# ═ / = : Unmerged
	# ✖ / - : Deleted (This indicator can't be shown, as NERDTree doesn't display deleted files. I have no prefect idea to solve this problem currently.)
	# ✗ / × : Dirty (Only for directory)
	# ✔ / ø : Clean (Only for root directory)
	#✔: repository clean
		#●n: there are n staged files
	#✖n: there are n files with merge conflicts
		#✚n: there are n changed but unstaged files
	#…n: there are n untracked files
	#⚑n: there are n stash entries
	modi=$(( $staged + $changed )) # + $untracked + $deleted
	#echo modi: $modi 1>&2
	local res
	if [[ $modi -gt 0 || $untracked -gt 0 || $deleted -gt 0 ]]; then
		#[[ $modi -gt 0 ]] && res=$res$(echo -e "${green}~$modi") #✚
		#res="$res$norm"
		[[ $staged -gt 0 ]] && res=$res$(echo "\$green+$staged ") #✚
		#res="$res$norm"

		[[ $changed -gt 0 ]] && res=$res$(echo "\$yellow_bright~$changed ") #✚
		#[[ $changed -gt 0 ]] && res=$res$(echo -e "${yellow}=$changed$norm") #✚
		#res="$res$norm"

		[[ $deleted -gt 0 ]] && res=$res$(echo "\$red-$deleted ") #✖
		#res="$res$norm"

		[[ $untracked -gt 0 ]] && res=$res$(echo "\$red_bright?$untracked ") #…
		#res="$res$norm"

		#[[ $ignored -gt 0 ]] && res=$res$(echo -e "${grey} !$ignored") #…
		res="$res\$norm "
		echo "$res"
	  fi
	}
function compare_with_remote(){
	#curr_remote=$(current_remote)
	LOCAL=$(git rev-parse @)
	#REMOTE=$(git rev-parse @{u}) # from local
	REMOTE=$(git ls-remote 2>/dev/null | awk "/HEAD/ {print \$1}")
	BASE=$(git merge-base @ @{u})
	#echo LOCAL:$LOCAL REMOTE:$REMOTE BASE:$BASE
	if [ $LOCAL = $REMOTE ]; then
		true #echo "Up-to-date"
	  elif [ $LOCAL = $BASE ]; then
		echo -e "${yellow}NEED TO PULL !${norm}" 1>&2
	  elif [ $REMOTE = $BASE ]; then
		echo -e "${yellow}NEED TO PUSH !${norm}" 1>&2
	  else
		echo -e "${red_bright}DIVERGED !!${norm}" 1>&2
	  fi
		}

function get_remote_repo_name(){
	git config --get remote.$(current_remote).url | sed -E 's|.*/(.*).git/?$|\1|'	
	}
function get_all_remotes(){
	remotes=$(git remote show)
	echo $remotes
	}
function git_rebase_status(){
	git status | head -n 1 # rebase in progress; onto 0103a6e
	}

function git_staged(){
	local all=$(git status -s --untracked-files --porcelain 2> /dev/null) 
	local staged=$(echo "$all" | grep "^[ADM]" | wc -l) # git status -s --untracked-files --porcelain | grep "^(A|D|M)"
	staged=`echo $staged`
	[[ "$staged" != "0" ]] && staged=" {$staged}"
	[[ "$staged" == "0" ]] && staged=""
	echo "$staged"
	}
function git_changed(){
	local changed=$(git status -s --untracked-files --porcelain 2> /dev/null | grep -E "^.{0,1}M" | wc -l) # but unstaged \?\?|
	changed=`echo $changed`
	[[ "$changed" != "0" ]] && changed=" ~$changed"
	[[ "$changed" == "0" ]] && changed=""
	echo "$changed"
	}
function git_untracked(){
	local untracked=$(git status -s --untracked-files --porcelain 2> /dev/null | grep -E '^\?\?' | wc -l)
	untracked=`echo $untracked`
	[[ "$untracked" != "0" ]] && untracked=" +$untracked"
	[[ "$untracked" == "0" ]] && untracked=""
	echo "$untracked"
	}
function git_deleted(){
	local all=$(git status -s --untracked-files --porcelain 2> /dev/null) 
	local deleted=$(echo "$all"| grep -E "^.{0,1}D" | wc -l)
	deleted=`echo $deleted`
	[[ $deleted -gt 0 ]] && deleted="-$deleted "
	[[ $deleted -eq 0 ]] && deleted=""
	echo "$deleted"
	}
function git_prompt(){
	#[[ "$curr_branch" != "" ]] && echo -e " $green[$green $curr_branch$magenta->$(current_remote)$cyan_bold$(files_status)$green ]$norm " #$green_dim$
	[[ "$curr_branch" != "" ]] && echo "$cyan_back \w $norm $green$curr_branch$magenta->$(current_remote) $cyan_bold$green+$staged$red-$deleted$norm$cyan_back > $norm " #$green

	#[[ "$curr_branch" != "" ]] && echo "$green $curr_branch$magenta-> $cyan_bold$(files_status)$norm" 
	}

function remote_for_ps1(){
	curr_remote=$(current_remote)
	[[ "$curr_remote" != "" ]] && curr_remote="->$curr_remote [$(get_remote_repo_name)]"
	echo "$curr_remote"
	}
function branch_for_ps1(){
	curr_branch=$(current_branch)
	[[ "$curr_branch" != "" ]] && curr_branch=" $curr_branch"
	echo "$curr_branch"
	}
function renametab() {
	# todo: oldpwd for *nix (~/.oldpwd for msys only)
	[[ "$(cat ~/.oldpwd)" == "$(pwd)" ]] && return
	#echo "-$(pwd)-" 1>&2
	#echo "=$OLDPWD="  1>&2
	#echo "rename tab" 1>&2
	if [ "$ConEmuPID" != "" ]; then $ConEmuBaseDir/ConEmuC -GuiMacro Rename 0 "${PWD##*/}" 1> /dev/null; fi
	if [ "$TERM_PROGRAM" == "Apple_Terminal" ]; then echo -ne "\033]0;${PWD##*/}\007"; fi
	pwd > ~/.oldpwd
	#PREV_TAB="${PWD##*/}"
	}

GIT_PROMPT="\[$cyan_back\] \w \[$norm\]\[$green\]\$(branch_for_ps1)\[$magenta\]\$(remote_for_ps1)\[$green\]\$(git_staged)\[$yellow\]\$(git_changed)\[$red\]\$(git_untracked)\[$blue_dim\]\$(git_deleted)\[$norm\] \[$cyan_back\] \t > \[$norm\] \$(renametab)"
	#\[$cyan_bold\]
	#http://mediadoneright.com/content/ultimate-git-ps1-bash-prompt
	#export PS1="\\033[0;34;48m[\u / \h] \\033[0;32;49m\w$git_branch: \[\033[m\]" #\\033[0;33;49m
	#parse_git_branch() { git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/' }
	#\[<color>\] чтобу у bash'а не ехала крыша при определении длины промпта и текст командной строки не "съезжал" на следующую строку.

cmd_git_color_git_diff(){
	if  [[ $1 == "M" ]] #grep -q "^M" <<< "$i"
		then echo -e "${yellow} $2 ${norm}"
	  elif [[ $1 == "D" ]] #grep -q "^D" <<< "$i"
		then echo -e "${red} $2 ${norm}"
	  elif [[ $1 == "A" ]] #grep -q "^A" <<< "$i"
		then echo -e "${green} $2 ${norm}"
	  else echo -e "$2"
	  fi
	}

cmd_git_help(){ # g-help
	# less "$HOME_UTILS_GIT/readme.md"
	clear
	#less -n -r $UTILS_PRJ_HOME/readme.clr
	while IFS='' read -r line || [[ -n "$line" ]]; do
		eval "echo -e \"$line\""
	done < <(cat $HOME_UTILS_GIT/help.clr ) #| head -n 2
	}
cmd_git_uninstall(){ 					# g-uninstall
	null
	}
cmd_git_switch_version(){ 				# gitsw
	#echo "Use syntax: . gitsw"
	[[ "$APPS" = "" ]] && echo "\$APPS is not defined; setup it (ex. in ~/.bash_profile or by 'varadd APPS <path>') and reopen shell" && exit 1

	if [ -d "$APPS/Git2.4.6" ]; then
		echo "set default git to 2.4.6"
		cmd //c "move %APPS%/Git %APPS%/Git1.9.5 && move %APPS%/Git2.4.6 %APPS%/Git"
	  else
		if [ -d "$APPS/Git1.9.5" ]; then
			echo "set default git to 1.9.5"
			cmd //c "move %APPS%/Git %APPS%/Git2.4.6 && move %APPS%/Git1.9.5 %APPS%/Git"
		  fi
	  fi
	}
#cmd_utils_git_edit_gitignore(){				# gei
#	rootpath=`git rev-parse --show-toplevel`
#	ed `git rev-parse --show-toplevel`/.gitignore
#	}

cmd_git_append(){ 					# ga
	echo -e "BRANCH: $green$(current_branch)$norm"
	files="$1"
	if [[ "$files" == "" ]]; then
		git add -A .
	  else
		git add "$files"
	  fi
	}
cmd_git_append_and_commit(){ 				# gac
	local msg=$1

	#echo -e "BRANCH: $green$(current_branch)$norm"
	savepath=`pwd`
	rootpath=`git rev-parse --show-toplevel`
	cd "$rootpath"
	local changes
	changes=`git status -s --untracked-files | wc -l`
	if [[ "$changes" != "0" ]]; then # append_and_commit
		git add -A .
		if [[ "$msg" == "" ]]; then
			[[ "$GITHOST" == "" ]] && echo "\$GITHOST not defined!" && cd "$savepath" && return
			msg="$(echo $GITHOST)-up"
		  fi
		git commit -m "$msg" # $(date +'%d.%m.%y_%k:%M')
	  fi
	cd "$savepath"
	}
cmd_git_append_and_commit_amend(){ 			# gacm
	echo -e "BRANCH: $green$(current_branch)$norm"

	git add -A .
	#test not staged and echo!
	if [[ "$1" != "" ]]; then
		git commit --amend -m "$1"
	  else
		git commit --amend 
	  fi
	}
cmd_git_append_by_names(){ 				# gad
	savepath=`pwd`
	rootpath=`git rev-parse --show-toplevel` # get repo root path
	cd "$rootpath"
	echo -e "BRANCH: $green$(current_branch)$norm"
	files="$1"
	[[ "$files" == "" ]] && git add -A .
	[[ "$files" != "" ]] && git add "$files"
	cd "$savepath"
	}
cmd_git_append_by_mask_commit_and_push(){ 		# gas
	# add by mask, commit and push
	files="$1"
	msg=$2
	[[ "$files" == "" ]] && echo "[ADD AND PUSH] mask is missed !" && return

	cmd_git_append "$files"
	cmd_git_сommit_staged $msg
	cmd_git_push
	}

cmd_git_сommit_staged(){ 				# gc
	msg=$1
	#pwd | tr 'a-z' 'A-Z'
	#echo -e "\033[0;34;48m sss \033[m"
	echo -e "BRANCH: $green$(current_branch)$norm"

	#test not staged and echo!

	if [[ "$msg" == "" ]]; then
		[[ "$GITHOST" == "" ]] && echo "\$GITHOST not defined!" && return
		msg="$(echo $GITHOST)-up"
	  fi
	git commit -m "$msg" # $(date +'%d.%m.%y_%k:%M')
	}
cmd_git_commit_staged_amend(){ 				# gcm
	echo -e "BRANCH: $green$(current_branch)$norm"

	#test not staged and echo!
	if [[ "$1" != "" ]]; then
		git commit --amend -m "$1"
	  else
		git commit --amend 
	  fi
	}

cmd_git_diff_file_list_this_and_prior_commits(){ 	# gdi gdi1
	# all files
	#[[ "$1" == "" ]] 		&& git diff --word-diff --color	| less -R				&& return 
	fname="$1"
	mode="$2"
	log_print "fname: $fname"
	log_print "mode:  $mode"

	if [[ "$fname" == "" ]]; then
		{
			git diff --stat=200 --color | sed -n '$! p'
			while IFS= read -r line; do
				echo -e " ${yellow}UNTRACKED: $line${norm}"
			  done < <(git ls-files --others --exclude-standard) # untracked files
		} | awk '{print NR "\t" $0}' #'NR!=FNR {FNR==1?c=NR:1} FNR<c-1'   awk 'NR>n{print A[NR%n]} {A[NR%n]=$0}' n=1
		#array=($(git ls-files --others --exclude-standard)) 
		#if [ "${#array[@]}" -ne 0 ]; then
		#	echo -e " ${yellow_back}== UNTRACKED ==${norm}"
		#	for i in "${array[@]}"; do echo -e " ${yellow}$i${norm}"; done
		#  fi
		return 
	  fi

	# hash
	#echo "$1"
	if [[ "fname" =~ "[a-zA-Z0-9]{7}" ]]; then
		git diff "$1" "$1~1" --word-diff  --color | less -R 
		return 
	  fi

	# one file
	#echo git diff HEAD --word-diff --color -U99999 "./$1"
	if [[ "$fname" != "" ]]; then
		if [ "$mode" == "" ]; then
			status=`git diff --name-status HEAD^ HEAD "$fname" | awk '{print $1}'`
			res=`which pygmentize 2>&1`
			if [ "$?" == "0" ]; then
				[[ "$status" == "??" ]] && cat "$fname" | pygmentize -g | less -MNR && return # untracked
			  else
			  	[[ "$status" == "??" ]] && cat "$fname" | less -MNR && return # untracked
			  fi
			[[ "$status" == "D" ]] && git show HEAD:"$fname" | less -MNR && return #git show $(git rev-list --max-count=1 --all -- "$1"):"$1" #deleted
			git diff HEAD --color -U99999 "$1" | tail -n +6 | less -MNR 
		  else
		  	[ "$mode" == "last" ] && git diff HEAD~1 HEAD --color -U99999 "$fname" | tail -n +7 | less -MNR 
		  	[ "$mode" == "prev" ] && git diff HEAD~2 HEAD~1 --color -U99999 "$fname" | tail -n +7 | less -MNR 
		  fi
		#return 
	  fi
	# less $(git status -uno -s --color | cut -c 4-) # :n :p


	#[[ "$1" != "" ]] 		&& git diff HEAD --word-diff --color "$1" | sed -n '6,$p' 
	#[[ "$1" != "" ]] 		&& git diff HEAD --word-diff --color "$1" | more -R #less -R 	&& return # file "HEAD~1" "HEAD" tail -n +6  sed -n '6,$p' # -R or --RAW-CONTROL-CHARS  Like -r, but only ANSI "color" escape sequences are output in "raw" form. (...)

	#[[ "$1" != "" ]] 		&& CLICOLOR_FORCE= git diff HEAD --word-diff --color "$1" | less -R  #CLICOLOR_FORCE= ls -G | less -R
	#[[ "$1" != "" ]] 		&& awk '(NR > 5)' <(git diff HEAD --word-diff --color "$1")

	#rn=1
	#while IFS= read line; do
	#	[ $rn -gt 5 ] && printf '%s\n' "$line"
	#	(( rn = rn + 1 ))
	#  done < <(git diff HEAD --word-diff --color $1)

	#git diff --stat=200 HEAD~1 HEAD --color | sed -n '$! p'
	}
cmd_git_diff_file_list_menu(){ 				# gdifs gids gdis
	# shows menu to choose file which diff you want to view

	mode="$1" # "": work/head  last:head/head~1
	# TODO: if total files > 9 -> wait second key
	# TODO: add nexp/prev commit (correct gids and pass "hash~<n> hash~<-n>")
	# TODO: to view deleted file - cirrect gdis)

	#put untracked fnames to arr
	if [ "$mode " == "" ]; then
		arr=($(git ls-files --others --exclude-standard)) 
	  fi
		#array=($(cmd_git_status_with_untracked | grep -v '??' | cut -c 4-)) 
		#array=($({(git diff --stat=200 --color | sed -n '$! p'); for i in "${arr[@]}"; do echo -e " ${yellow}$i${norm}"; done;	} | awk '{print NR "\t" $0}' )) 

	#put tracked fnames to array:
	[ "$mode" == "" ] && array=($({(git status -s --untracked-files --porcelain | grep -v '??' | cut -c 4-); for i in "${arr[@]}"; do echo "$i"; done;	})) 
	(( tot = ${#array[@]} )) 
	[[ $tot -eq 0 ]] && mode="last"

	changes=$(echo `git status -s --untracked-files | wc -l`)
	[[ "$changes" == "0" && "$mode" == "" ]] && mode=last 

	[ "$mode" == "last" ] && array=($(git diff head head~1 --name-only | sed -E "s/^(.*)$/\"\1\"/g" )) #   while read x; do echo '"'"$x"'"'; done
	[ "$mode" == "prev" ] && array=($(git diff head~1 head~2 --name-only | sed -E "s/^(.*)$/\"\1\"/g" ))
	if [ "$mode" != "" ]; then
		(( tot = ${#array[@]} )) 
		#echo tot: $tot #+ ${#arr[@]}
		[[ $tot -eq 0 ]] && echo "No files found" && return
	  fi
	#echo "${array[0]}"
	#for i in "${array[@]}"; do echo "$i"; done; return # echo "${array[@]}"
	clear
	bound=${#array[@]} 
	(( bound = bound - 1 )) #; echo bound: $bound

	# show header with enumed file list:
	function show_files() {
		[ "$mode" == "" ] && {(git diff --stat=200 --color | sed -n '$! p'); for i in "${arr[@]}"; do echo -e " ${yellow}UNTRACKED: $i${norm}"; done;} | awk '{print NR "\t" $0}' 
		[ "$mode" == "last" ] && (git diff head~ head --stat --color) | sed -n '$! p' | awk '{print NR "\t" $0}' 
		[ "$mode" == "prev" ] && (git diff head~1 head~2 --stat --color) | sed -n '$! p' | awk '{print NR "\t" $0}' 
		}
	show_files
	# show menu
	current=0 # current index for view diff
	init_prompt="${yellow}Press key with your choice${norm} - (${green}0..9${norm}-file_number  ${green}N${norm}-next  ${green}P${norm}:revious  ${green}<CR>${norm}-current  ${green}Q${norm}-quit: " 
	looped_prompt="\n$init_prompt"
	#prompt_out=" ${yellow}Viewed #$(( current + 1 )) - '${array[$current]}'${norm} $looped_prompt"
	fail_prompt=" ${red}$n is out of bounds (1..$(( bound + 1 )) ) !${norm} $looped_prompt"
	(( num = current + 1 )) # echo num: $num
	#gid "${array[$current]}"
	echo -n -e "$init_prompt"
	read -rsn1 n
	echo -n -e "$n"
	while true;	do
		#clear
		is_invalid=1 # unknown key pressed
		if [ "$n" == "Q" -o "$n" == "q" ]; then 
			echo "" #<CR>
			break
		  fi
		if [ "$n" == "C"  -o  "$n" == "c"  -o  "$n" == "" ]; then
			[ "$n" == "" ] && echo -n "<CR>"
			is_invalid=0
		  fi
		if [ "$n" == "N" -o "$n" == "n" ]; then
			if [ $current -lt $bound ]; then 
				(( current = current + 1 )) 
				is_invalid=0
			  else
			  	is_invalid=2 # out of bounds
			  fi
		  fi
		if [ "$n" == "P" -o "$n" == "p" ]; then
			if [ $current -gt 0 ]; then
				(( current = current - 1 ))
				is_invalid=0
			  else
			  	is_invalid=2 # out of bounds
			  fi
		  fi
		if [[ $n =~ ^[0-9]$ ]]; then #if [ "$var" -eq "$var" ] 2>/dev/null; then
			(( new_idx = n - 1 ))

			if [[ $new_idx -le $bound  &&  $new_idx -ge 0 ]]; then 
				(( current = new_idx )) 
				is_invalid=0
			  else
			  	is_invalid=2 # out of bounds
			  fi
		  fi
		if [ $is_invalid -eq 2 ]; then
		  	echo -n -e "$fail_prompt"
			read -rsn1 n
			echo -n -e "$n"
			continue
		  fi
		if [ ! $is_invalid -eq 0 ]; then
			echo -n -e " ${red}'$n' is not valid choice !${norm} $looped_prompt"
			read -rsn1 n
			echo -n -e "$n"
			continue
		  fi
		# pwd
		#[ ! -f "./${array[$current]}" ] && echo -e "\n" && ls "./${array[$current]}" # - not found
		eval file_wo_quotes="${array[$current]}"
		#echo -e "\n$n"
		if [ -f "$file_wo_quotes" ]; then
			#echo gdis "${array[$current]}" "$mode"
			cmd_git_diff_file_list_this_and_prior_commits "$file_wo_quotes" "$mode"
			clear
			echo -e "${cyan}Viewed #$(( current + 1 )) - '$file_wo_quotes'${norm}" # "$prompt_out"  #$(( current + 1 ))
			show_files
			echo -n -e "$init_prompt"
		  else
		  	echo -e " ${yellow}File (#$(( current + 1 ))) not found (deleted?) - '$file_wo_quotes'${norm}"
			echo -n -e "$init_prompt"
		  fi
		read -rsn1 n
		echo -n -e "$n"
	  done
	}
cmd_git_diff_clear_all(){				# dclear
	git reset --hard
	git clean -f 
	}

cmd_git_branch_show_local_or_switch(){ 			# gib gibs
	if [[ "$1" == "" ]]; then
		echo "local branches:"
		git branch -lvv
		#git for-each-ref --format='%(refname:short) <- %(upstream:short)' refs/heads
		#git for-each-ref --format=$'\n'' '' '' '' '' '' ''/%(refname:short);%(upstream:short)' refs/heads | tr ';' $'\n'
		#git rev-parse --symbolic-full-name --abbrev-ref master@{u}
	  else
	  	branch=$(find_branch "$1") 
	  	[ $? -eq 0 ] && git checkout $branch
	  fi
	}
cmd_git_branch_show_remote_only(){ 			# gibr
	echo "remote branches:"
	git branch -r -vv #all
	}
cmd_git_branch_show_unmerged(){ 			# gibnm
	echo "unmerged branches:"
	git branch --no-merged
	}
cmd_git_branch_show_local_and_remote(){			# giba - add
	echo "local and remote branches:"
	if [[ "$1" == "" ]]; then
		git branch -avv #  List of all branches and their corresponding remote branches
	  else
	  	branch=$(find_branch "$1") 
	  	[ $? -eq 0 ] && git checkout $branch
	  fi
	}

cmd_git_branch_new(){ 					# gibn
	if [[ "$1" == "" ]]; then
		echo "[CREATE NEW BRANCH] first param must be Name"
	  else
	  	git checkout -b "$1"
	  fi
	}
cmd_git_branch_delete_any_way(){ 			# gibdf
	if [[ "$1" == "" ]]; then
		echo branch name IS MISSED 1>&2 && exit
	  else
	  	branch=$(find_branch "$1") 
	  	[[ "$branch" == "" ]] && echo -e "${red}branch NOT FOUND$norm" 1>&2 && return
	  	curr_branch=$(current_branch)
	  	[[ $curr_branch == "$branch" ]] && echo -e "${red}can't delete itself $norm" 1>&2 && return
	  	git branch -D $branch
	  fi
	}
cmd_git_branch_delete_if_merged(){ 			# gibd
	if [[ "$1" == "" ]]; then
		echo branch name IS MISSED 1>&2 && return
	  else
	  	branch=$(find_branch "$1") 
	  	[[ "$branch" == "" ]] && echo -e "${red}branch NOT FOUND$norm" 1>&2 && return
	  	curr_branch=$(current_branch)
	  	[[ $curr_branch == "$branch" ]] && echo -e "${red}can't delete itself $norm" 1>&2 && return
	  	git branch -d $branch # если ветка была смержена
	  fi
	}

cmd_git_branch_merge_after_pull(){ 			# gim
	source_branch=$(find_branch "$1") #; echo branch: $branch
	exitcode=$?
	[ $exitcode -ne 0 ] && echo not found && return

	currbranch=$(current_branch)
	echo "from '$source_branch' to '$currbranch'"

	echo "Pull '$source_branch'"
	#git checkout $branch
	cmd_git_branch_show_local_or_switch $source_branch || return
	cmd_git_pull || cmd_git_branch_show_local_or_switch $source_branch # || return

	#git checkout $source_branch
	cmd_git_branch_show_local_or_switch $currbranch || (echo "FAIL! ANOTHER BRANCH !!" && return)

	#echo returncode: $returncode
	#echo current_branch: $(current_branch)
	#[ $returncode -eq 1 ] && echo "Find branch by $1*: AMBIGUOUS" && return
	#[ $returncode -eq 2 ] && echo "Find branch by *$1*: NOT FOUND" && return
	#[ $returncode -eq 3 ] && echo "Find branch by *$1*: AMBIGUOUS" && return

	git merge $source_branch
	#echo done
	}
cmd_git_branch_merge_with_local(){ 			# giml
	branch=$(find_branch "$1") # result; echo result:$result; branch=${result}
	returncode=$?
	#echo returncode: $returncode
	#echo current_branch: $(current_branch)
	[ $returncode -ne 0 ] && echo not found && return
	#[ $returncode -eq 1 ] && echo "Find branch by $1*: AMBIGUOUS" && return
	#[ $returncode -eq 2 ] && echo "Find branch by *$1*: NOT FOUND" && return
	#[ $returncode -eq 3 ] && echo "Find branch by *$1*: AMBIGUOUS" && return

	git merge $branch
	#echo done
	}
cmd_git_branch_target_branch_with_this_after_pull(){ 	# gimto
	currbranch=$(current_branch)
	echo currbranch: $currbranch

	tobranch=$(find_branch "$1")
	echo tobranch: $tobranch

	  # [ $? -eq 0 ] 
	if [[ "$tobranch" != "" ]]; then
		git checkout $tobranch
		  [ $? -ne 0 ] && return
		cmd_git_pull # fetch and merge
		  [ $? -ne 0 ] && return
		git merge $currbranch
		  [ $? -ne 0 ] && return
		git checkout $currbranch
		#gil 7
	  fi
	}
cmd_git_branch_target_local_branch_with_this(){ 	# gimtol
	currbranch=$(current_branch)
	echo currbranch: $currbranch

	tobranch=$(find_branch "$1")
	echo tobranch: $tobranch

	  # [ $? -eq 0 ] 
	if [[ "$tobranch" != "" ]]; then
		git checkout $branch
		  [ $? -ne 0 ] && return
		git merge $currbranch
		  [ $? -ne 0 ] && return
		git checkout $currbranch
		gil 7
	  fi
	}

cmd_git_log_host_first(){ 				# gil
	# 	[[ $curr_branch == "$branch" ]] && echo -e "${red}can't delete itself $norm" 1>&2 && exit
	# 	git branch -d $branch # если ветка была смержена
	#git log --graph -n 20 --full-history --all --date=iso --color --pretty=format:"%x1b[31m%h%x09%x1b[32m%d%x1b[0m%x20%s $blue(%an - %ad%x08%x08%x08%x08%x08%x08%x08%x08%x08)%Creset"
	#http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs

	if [[ "$1" == "" ]];then
		commits_num=20
	  else
	  	commits_num=$1
	  fi

	BRANCH="$d"
		#git log --graph -n 20 --full-history --all --date=iso --color --pretty=format:"$red%h$green%d %x09% %s $blue(%an - %ad%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08)%Creset"
	git log --graph -n $commits_num --full-history --source  --all --date=iso --color --author-date-order --decorate \
		--pretty=format:"$git_green$COMMIT $git_yellow$HASH $git_norm$git_white$TIME2 $BRANCH $git_grey $AUTHOR $git_white $git_green $REFNAME" #$git_blue $git_green
	# git stores the branch name at the most recent commit of the branch. All commits in the history are equal and anonymous
	#	--pretty=oneline  --decorate
	#        while IFS=+ read -r hash time branch message; do                                            \
	#            timelength=$(echo \"$time\" | sed -r \"s:[^ ][[]([0-9]{1,2}(;[0-9]{1,2})?)?m::g\");     \
	#            timelength=$(echo \"16+${#time}-${#timelength}\" | bc);                                 \
	#            printf \"%${timelength}s    %s %s %s\n\" \"$time\" \"$hash\" \"$branch\" \"$message\";  \
	#        done < <( git log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset)+%C(dim black)(%cr)%C(reset)+%C(auto)%d%C(reset)++\n+++       %C(bold black)%an%C(reset)%C(black): %s%C(reset)' && echo)
	# bc
		# --branches=master --remotes=bb
		#git log --graph -n $commits_num --full-history --all --date=format:'%m-%d' --color --pretty=format:"$grey$HASH $tab$norm$yellow%ad $white$COMMIT $green$BRANCH $blue$AUTHOR $white" # %Y-  %H:%M:%S

	#git log -n 20 --oneline --abbrev-commit --all --graph --pretty=format:"%C(yellow)%h%x09%Creset%x09%x09%s (%an)" $*
	#git log -last --pretty=format:"%C(yellow)%h%x09%Creset%an%x09%x09%s" --decorate -20 --graph $*
	}
cmd_git_log_hash_first(){ 				# gilb
	if [[ "$1" == "" ]];then
		commits_num=20
	  else
	  	commits_num=$1
	  fi

	#git log --graph -n 20 --full-history --all --date=iso --color --pretty=format:"$red%h$green%d %x09% %s $blue(%an - %ad%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08)%Creset"
	git log --graph -n $commits_num --full-history --date=iso --color --pretty=format:"$git_grey$HASH $tab$git_norm$git_yellow$TIME $git_white$COMMIT $git_green$BRANCH $git_blue$AUTHOR $git_white" 
	#git log --graph -n $commits_num --full-history --all --date=format:'%m-%d' --color --pretty=format:"$grey$HASH $tab$norm$yellow%ad $white$COMMIT $green$BRANCH $blue$AUTHOR $white" # %Y-  %H:%M:%S

	#git log -n 20 --oneline --abbrev-commit --all --graph --pretty=format:"%C(yellow)%h%x09%Creset%x09%x09%s (%an)" $*
	#git log -last --pretty=format:"%C(yellow)%h%x09%Creset%an%x09%x09%s" --decorate -20 --graph $*
	}
cmd_git_log_with_files(){ 				# gilf
	if [[ "$1" == "" ]];then
		commits_num=7
	  else
	  	commits_num=$1
	  fi
	git log --all --full-history --decorate --date=iso --pretty=format:"%C(red)%h - %C(green) %d %C(yellow)%s %C(blue)(%an - %ad%x08%x08%x08%x08%x08%x08%x08%x08%x08)%Creset" -n $commits_num --name-status
	}
cmd_git_log_hash_first_with_merges(){ 			# gilm
	git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative 
	}
cmd_git_log_with_file_diff(){ 				# gild
	git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative -p
	}
cmd_git_gilh(){ 					# gilh ?? 
	git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short #??
	}
cmd_git_last_n_commits_stat_simple(){ 			# gils
	if [[ "$1" == "" ]];then
		commits_num=10
	  else
	  	commits_num=$1
	  fi
	echo "ADDED   DELETED"

	git log -n $commits_num -last   --pretty=format:"%h%x09%Creset%an%x09%x09%s" --decorate --numstat | grep -v "^$"  | grep -vE "^[0-9a-f]{7}" | grep -vE "^-"

	#git log --numstat --pretty --oneline 0f5d22e..HEAD -- <filename>
	}
cmd_git_last_n_commits_stat_with_hash(){ 		# gilsh
	if [[ "$1" == "" ]];then
		commits_num=10
	  else
	  	commits_num=$1
	  fi
	echo "ADDED   DELETED"
	git log -n $commits_num 	--pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --numstat

	#git log --numstat --pretty --oneline 0f5d22e..HEAD -- <filename>
	}

cmd_git_remotes_show(){ 				# girs
	#git remote -v
	curr_remote=$(current_remote)
	remotes=$(git remote show)
	#echo remotes: $remotes
	for name in $remotes; do 
		if [[ "$name" == "$curr_remote" ]]; then
			echo -e "${red}$name$norm"
		  else
		  	echo $name
		  fi
	  done
	}
cmd_git_remotes_show_detail(){ 				# girx
	#git remote -v
	if [[ "$1" != "" ]]; then
		git remote show $1
	  else
		remotes=$(git remote show)
		log_print remotes: $remotes
		for remote in $remotes; do 
			log_print "remote: $remote"
			[[ "$remote" == "$remote" ]] && git remote show $remote
		  done
	  fi
	# when - error: invalid branch.master.merge; cannot rebase onto > 1 branch
	# run gect and replace for [branch "ex.master"] 
	# 'rebase = true' to 'rebase = false'
	}
cmd_git_remote_rename(){				# girn
	# rename current remote
	[[ "$1" == "" ]] && echo "[RENAME REMOTE] New name is missed !" && return
	#remotes=$(ls -1)
	curr_remote=`current_remote`
	# echo curr_remote: $curr_remote
	if [[ "$curr_remote" != "" ]]; then
		git remote rename $curr_remote "$1"
	  else
		remotes=$(git remote show)
		#echo remotes: $remotes
		remotes_cnt=$(echo -e "$remotes" | wc -l)
		#echo remotes_cnt: $remotes_cnt
		if [[ $remotes_cnt -eq 1 ]]; then
			git remote rename $remotes "$1"
		  else
		  	echo remote not defined
		  fi
	  fi
	}
cmd_git_remote_set_default(){ 				# giru
	remote_mask=$1
	[ "$remote_mask" == "" ] && error "$remote_mask is missed (1st param)" && return
	log_print "remote_mask: $remote_mask"
	remote_alias=`git remote show | grep -E "^$remote_mask"` #`find_remote $remote_mask`
	
	curr_branch=`current_branch`

	notice "set upstream"
	res=`git branch --set-upstream-to $remote_alias/$curr_branch 2>&1`
	err_code=$? 
	if [ "$err_code" != "0" ]; then
		error "$res"
		return $err_code
	  else
		echo -e "$res"
		notice "set rebase to false.."
		sed -i -E 's/(\s)+rebase = true/\1rebase = false/g' .git/config
	  fi

	#res=`git branch --set-upstream-to $remote_alias/$curr_branch 2>&1`
	#if [ "$?" != "0" ]; then
	#	git fetch $remote_alias $curr_branch
	#	git branch --set-upstream-to $remote_alias/$curr_branch 
	#	echo "\$?: $?"
	#  fi
	}
cmd_git_remote_delete(){				# gird
	# delete remote
	[[ "$1" == "" ]] && echo "[DELETE REMOTE] name is missed !" && return
	#remotes=$(ls -1)
	remote=$1
	# echo curr_remote: $curr_remote
	if [[ "$remote" == "all" ]]; then
		remotes=$(git remote show)
		#echo remotes: $remotes
		remotes_cnt=$(echo -e "$remotes" | wc -l)
		#echo remotes_cnt: $remotes_cnt
		if [[ $remotes_cnt -eq 1 ]]; then
			git remote remove $remotes
		  else
		  	echo -e "${red}no one remote defined${norm}"
		  fi
	  else
		git remote remove $remote
	  fi
	}
cmd_git_remote_add(){					# gira
	remote_alias=$1
	remote_name=$2
	prj_group=$3
	# todo: remote repo - alternative name
	#remote_url=$2
	[ "$remote_alias" == "" ] && error "remote alias is missed (1st param)" && return
	#[ "$remote_url" == "" ] && error "remote url is missed (2nd param)" && return
	#git remote add $1 $2
	#return
	log_print "remote_alias: $remote_alias"
	remote_url=`cat $HOME/.utils-git/remotes/$remote_alias` 2> /dev/null
	[ "$remote_url" == "" ] && error "remote alias is not found ($HOME/.utils-git/remotes/$remote_alias)" && return

	remote_url=`eval echo "$remote_url"`
	log_print "remote_url: $remote_url"
	if [ "$remote_url" == "" ]; then
		error "${red}remote alias '$HOME/.utils-git/remotes/$remote_alias' not found${norm}"
		return
	  fi
		#if($url =~ /([^:]*:\/\/)?([^\/]+\.[^\/]+)/g) {
		#  print $2;
		#}
	prj_name=$(basename `git rev-parse --show-toplevel`)
	log_print "prj_name: $prj_name"

	[[ "$remote_name" == "." || "$remote_name" == "" ]] && remote_name=$prj_name
	log_print "remote_name: $remote_name"
	[ "$remote_name" == "" ] && error "remote name is not found" && return

	local GROUP_ID
	local GROUP_NAME
	local REPO_URL
	if [[ "$remote_url" =~ "gitlab" ]]; then
		[ "$GITLABUSER" == "" ] && error "\$GITLABUSER not defined!" && return
		[ "$PASSWORD" == "" ] && echo -n Enter password for $GITUSER: && read -s PASSWORD && echo
		if [[ "$TOKEN" == "" || "$TOKEN" == "null" ]]; then
			res=`curl -s --request POST "$remote_url/api/v3/session?login=$GITLABUSER&password=$PASSWORD"`
			log_print "res:        $res"
			TOKEN=`jq -r '.private_token' <<< $res`
		  fi
		log_print "TOKEN: $TOKEN"
		[[ "$TOKEN" == "" || "$TOKEN" == "null" ]] && error "Get token failed" && return

		# find group
		[ "$prj_group" == "" ] && prj_group=$GITUSER # $GITLABUSER
		find_group=`curl -s --header "PRIVATE-TOKEN:$TOKEN" "$remote_url/api/v3/namespaces?search=$prj_group"`
		log_print "find_group: $find_group"
		found=`jq 'length' <<< $find_group`
		log_print "found: $found"
		if [ "$found" == "1" ]; then
		  	GROUP_ID=`jq -r '.[] | .id' <<< $find_group`
		  	GROUP_NAME=`jq -r '.[] | .path' <<< $find_group`
		  else
			error "Group not found or ambigiouse!"
			jq -r '.[] | .name ' <<<$res
			return
		  fi
		log_print "GROUP_NAME: $GROUP_NAME"
		REPO_URL="$remote_url/$GROUP_NAME/$remote_name.git"
	  else
		REPO_URL="$remote_url/$remote_name.git"
	  fi
	log_print "REPO_URL: $REPO_URL"

	curr_branch=`current_branch`

	# test remote exists
	res=`git ls-remote "$REPO_URL" 2>&1` 
	res_code=$?
	#	echo "res_code: $res_code"
	#	error "$res"
	if [ "$res_code" != "0" ]; then # repo absent
		# create repo
		if [[ ! "$remote_url" =~ "gitlab" ]]; then
			[ "$GITUSER" == "" ] && error "\$GITUSER not defined!" && return
			[ "$PASSWORD" == "" ] && echo -n Enter password for $GITUSER: && read -s PASSWORD && echo
		  fi
		case "$remote_url" in
			*bitbucket*)
				notice "CREATE remote - $REPO_URL"
				#curl --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/repositories/ --data name=${PWD##*/} --data is_private='true' -k -s | jq ''
				res=`curl -k -s --user $GITUSER:$PASSWORD --data name=$remote_name --data is_private='true' https://api.bitbucket.org/1.0/repositories/`
				#echo "$?: $?"
				#jq '' <<< "$res"
				;;
			*github*)
				notice "CREATE remote - $REPO_URL  GITHUB.COM"
				#curl -u $GITUSER:$PASSWORD https://api.github.com/user/repos -k -d '{"name":"'${PWD##*/}'"}' -k -s | jq '.[] | .name + if .private then " - private" else "" end'
				res=`curl -u $GITUSER:$PASSWORD https://api.github.com/user/repos -k -d '{"name":"'$remote_name'"}' -k -s`
				#curl -u 'USER' https://api.github.com/user/repos -d '{"name":"REPO", "private":"true"}'
				#jq '.[] | .name + if .private then " - private" else "" end' <<< "$res"
				;;
			*gitlab*)
				notice "CREATE remote - $REPO_URL"
				#log_print "GITLABUSER: $GITLABUSER"
				#log_print "PASSWORD:   $PASSWORD"
				;;
			*)
				error "method for remote repo create not found !"
		  esac
	  fi
	notice "git remote add $remote_alias $REPO_URL"
	git remote add $remote_alias "$REPO_URL"

	if [ "$curr_branch" == "HEAD" ]; then 
		# new repo is empty
		notice "git remote update $remote_alias"
		git remote update $remote_alias
		notice "git branch -r"
		res=$(echo `git branch -r`) # get remote branch name
		err_code=$? && [ "$err_code" != "0" ] && echo "err_code: $err_code" && return
		if [ "$res" != "" ]; then
			notice "git checkout -t $res"
			res=`git checkout -t $res 2>&1`
			#err_code=$? && [ "$err_code" != "0" ] && echo "err_code: $err_code" && return
			err_code=$?
		  else
			# remote branch is absent
			# TODO if no files -> add some
			cmd_git_append_and_commit
			cmd_git_push
		  fi
	  else
		notice "git fetch --quiet $remote_alias $curr_branch" 
		res=`git fetch --quiet "$remote_alias" "$curr_branch" 2>&1` # vv -  отслеживаемые ветки
		err_fetch=$? && [ "$err_code" != "0" ] && echo "err_code: $err_code" && return
		if [ "$err_fetch" != "0" ]; then
			#error "$res"
			res=`git push "$remote_alias" "$curr_branch" 2>&1` 
			# remote branch не существует (или репо пуст)
		  fi
	  fi
	res=`cmd_git_remote_set_default $remote_alias`
	err_set_default=$? 
	if [ "$err_set_default" != "0" ]; then
		error "$res" # local branch не существует (или репо пуст)
	  else
		echo -e "$res" # return $err_set_default
	  fi
	}
cmd_git_remote_list(){					# girl
	local remote_alias=$1
	local prj_group=$2
	[ "$remote_alias" == "" ] && error "Remote alias is missed (1st param) !" && return
	#log_print "remote_alias: $remote_alias"
	
	local remote_url=`cat $HOME/.utils-git/remotes/$remote_alias` 2> /dev/null
	[ "$remote_url" == "" ] && error "remote alias is not found ($HOME/.utils-git/remotes/$remote_alias)" && return
	remote_url=`eval echo "$remote_url"`
	log_print "remote_url: $remote_url"
	
	notice "repo list"
	local res
	case "$remote_url" in
		*bitbucket*)
			[ "$GITUSER" == "" ] && error "\$GITUSER not defined!" && return
			[ "$PASSWORD" == "" ] && echo -n Enter password for $GITUSER: && read -s PASSWORD && echo
			if [ "$prj_group" == "" ]; then
				res=`curl -s --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/user/repositories/`
				jq -r '.[] | .name + "\t" + .owner + "\t" + if .is_private then "PRIVATE" else ".public." end' <<< "$res" | column -t | sort -f
			  else
				#curl -s -X GET --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/groups/$GITUSER/
				#curl -s -X GET --user $GITUSER:$PASSWORD https://api.bitbucket.org/2.0/repositories/$team1 | jq -r '.values | .[] | .name' | sort -f
				#team=`curl -s -X GET --user $GITUSER:$PASSWORD https://api.bitbucket.org/2.0/teams?role=admin | jq -r ".values | .[] | select(.username | contains(\"$prj_group\")) | .username"`
				group=`curl -s -X GET --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/groups/$GITUSER/ | jq -r ".[] | select(.name | contains(\"$prj_group\")) | .name"`
				if [ "$group" == "" ]; then
					error "Group not found"
					return
				  else
				  	#echo team1: $team1
					#curl -s -X GET --user $GITUSER:$PASSWORD https://api.bitbucket.org/2.0/teams/$team/repositories #| jq -r '.values | .[] | .name' | sort -f
					#res=`
					curl -s -X GET --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/groups/$group
					#`					jq -r '.repositories | .[] | .name + "\t" + if .is_private then "PRIVATE" else ".public." end' <<< "$res" | column -t | sort -f
				  fi
				#team1=`curl -s -X GET --user $GITUSER:$PASSWORD https://api.bitbucket.org/2.0/teams?role=admin | jq -r '.values| .[0] | .username'`
				#echo team1: $team1
				#curl -s --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/user/repositories/
			  fi
			#jq '' <<< "$res"
			#echo "\$?: $?"
			;;
		*github*)
			[ "$GITUSER" == "" ] && error "\$GITUSER not defined!" && return
			[ "$PASSWORD" == "" ] && echo -n Enter password for $GITUSER: && read -s PASSWORD && echo
			res=`curl -u $GITUSER:$PASSWORD -s -X GET "https://api.github.com/users/$GITUSER/repos"`
			#res=`curl -u $GITUSER:$PASSWORD https://api.github.com/user/repos -k -d '{"name":"'$prj_name'"}' -k -s`
			jq -r '.[] | .name + if .private then " - private" else "" end' <<< "$res"
			;;
		*gitlab*)
			[ "$GITUSER" == "" ] && error "\$GITUSER not defined!" && return
			[ "$PASSWORD" == "" ] && echo -n Enter password for $GITUSER: && read -s PASSWORD && echo
			
			if [ "$TOKEN" == "" ]; then
				res=`curl -s --request POST "$remote_url/api/v3/session?login=$GITLABUSER&password=$PASSWORD"`
				log_print "res:        $res"
				
				TOKEN=`jq -r '.private_token' <<< $res`
			  fi
			log_print "TOKEN: $TOKEN"

			local projects
			local repo_groups
			if [ "$prj_group" != "" ]; then
				repo_groups=`curl -s -X GET "$remote_url/api/v3/namespaces?search=$prj_group&private_token=$TOKEN"`
				log_print "repo_groups: $repo_groups"
				found=`jq 'length' <<< $repo_groups`
				log_print "found: $found"
				if [ "$found" != "1" ]; then
					error "Group not found or ambigiouse!"
					jq -r '.[] | .name ' <<<$repo_groups
					return
				  else
					group_id=`jq '.[] | .id' <<< $repo_groups`
					log_print "group_id: $group_id"
					projects=`curl -s --header "PRIVATE-TOKEN:$TOKEN" -X GET "$remote_url/api/v3/groups/$group_id/projects"`
					res_code=$?
				  fi
			  else
				#set -x
				projects=`curl -s -X GET $remote_url/api/v3/projects/owned?private_token=$TOKEN`
				#set +x
				res_code=$?
			  fi
			log_print "projects:        -$projects-"
			if [ "$projects" != '{"message":"401 Unauthorized"}' ]; then
			  	if [ "$res" == '""' ]; then
			  		error "no repo found"
			  	  else
					jq -r '.[] | .name' <<<$projects | sort
			  	  fi
			  else
			  	error "$projects"
			  fi
	  esac
	}
cmd_git_remote_list_groups(){				# girlg
	local remote_alias=$1
	local prj_group=$2
	[ "$remote_alias" == "" ] && error "Remote alias is missed (1st param) !" && return
	#log_print "remote_alias: $remote_alias"
	
	local remote_url=`cat $HOME/.utils-git/remotes/$remote_alias` 2> /dev/null
	[ "$remote_url" == "" ] && error "remote alias is not found ($HOME/.utils-git/remotes/$remote_alias)" && return
	remote_url=`eval echo "$remote_url"`
	log_print "remote_url: $remote_url"
	
	case "$remote_url" in
		*bitbucket*)
			[ "$GITUSER" == "" ] && error "\$GITUSER not defined!" && return
			[ "$PASSWORD" == "" ] && echo -n Enter password for $GITUSER: && read -s PASSWORD && echo
			#team1=`curl -k -s --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/user/privileges | jq -r '.teams | keys[0]'`
			#curl -k -s --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/user/privileges | jq -r '.teams | keys[0]'
			notice "groups list"
			curl -k -s -XGET --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/groups/$GITUSER | jq -r '.[] | .name + "\t" + .owber.username'
			#curl -k -s --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/user/privileges{$team1}
			#projects #
			#https://api.bitbucket.org/1.0/user/repositories/`
			#/REST/API/1.0/ADMIN/privileges
			#res=`curl -s --user $GITUSER:$PASSWORD https://api.bitbucket.org/1.0/user/repositories/`
			
			#jq -r '.[] | .name + if .is_private then "\tPRIVATE" else "" end' <<< $res
			#jq '' <<< "$res"
			#echo "\$?: $?"
			;;
		*github*)
			[ "$GITUSER" == "" ] && error "\$GITUSER not defined!" && return
			[ "$PASSWORD" == "" ] && echo -n Enter password for $GITUSER: && read -s PASSWORD && echo
			notice "teams list"
			curl -s -X GET --user $GITUSER:$PASSWORD "https://api.github.com/user/teams" | jq -r '.[] | .name'
			#res=`curl -u $GITUSER:$PASSWORD https://api.github.com/user/repos -k -d '{"name":"'$prj_name'"}' -k -s`
			#jq '.[] | .name + if .private then " - private" else "" end' <<< "$res"
			;;
		*gitlab*)
			[ "$GITUSER" == "" ] && error "\$GITUSER not defined!" && return
			[ "$PASSWORD" == "" ] && echo -n Enter password for $GITUSER: && read -s PASSWORD && echo

			
			if [ "$TOKEN" == "" ]; then
				res=`curl -s --request POST "$remote_url/api/v3/session?login=$GITLABUSER&password=$PASSWORD"`
				log_print "res:        $res"
				
				TOKEN=`jq -r '.private_token' <<< $res`
			  fi
			log_print "TOKEN: $TOKEN"

			local repo_groups
			notice "groups list"
			repo_groups=`curl -s -X GET "$remote_url/api/v3/namespaces?search=$prj_group&private_token=$TOKEN"`
			log_print "repo_groups: $repo_groups"
			found=`jq 'length' <<< $repo_groups`
			log_print "found: $found"
			if [ "$found" != "0" ]; then
				jq -r '.[] | .path ' <<<$repo_groups | sort 
			  else
				error "groups not found"
			  fi
	  esac
	}

cmd_git_status_with_untracked(){ 			# gis
	#pwd | tr 'a-z' 'A-Z'
	git status -s --untracked-files $* # --porcelain
	}
cmd_git_status_colored(){				# gisc
	#git diff --name-status | xargs cmd_git_color_git_diff #--delimiter="\n"  -L1
	git diff --name-status -z| while IFS= read -d '' a; do read -d '' b; cmd_git_color_git_diff $a "$b"; done 
	# xargs -L1 git push --all --quiet -u
	# xargs -I% svn rm %
	#git status -s --untracked-files $* # --porcelain
	}
cmd_git_status_ignored(){ 				# gisi
	git status --ignored
	}
cmd_git_status_untracked(){ 				# gisu
	#pwd | tr 'a-z' 'A-Z'
	git status -s --untracked-files $* # --porcelain
	compare_with_remote
	}

cmd_git_switch_version(){				# gsw
	#echo "Use syntax: . gitsw"
	[[ "$APPS" = "" ]] && echo "\$APPS is not defined; setup it (ex. in ~/.bash_profile or by 'varadd APPS <path>') and reopen shell" && return 1

	if [ -d "$APPS/Git2.4.6" ]; then
		echo "set default git to 2.4.6"
		cmd //c "move %APPS%/Git %APPS%/Git1.9.5 && move %APPS%/Git2.4.6 %APPS%/Git"
	  else
		if [ -d "$APPS/Git1.9.5" ]; then
			echo "set default git to 1.9.5"
			cmd //c "move %APPS%/Git %APPS%/Git2.4.6 && move %APPS%/Git1.9.5 %APPS%/Git"
		  fi
	  fi
	}
cmd_git_show_file_diff(){
	git show $1
	}

cmd_git_fetch(){ 					# gfe
	echo -e "${red}git fetch$norm"
	git fetch -vv --all 2>&1 | grep "\-> " 
		# This will list out your local branches with more information including what each branch is tracking and if your local branch is ahead, behind or both.
		# -all - fetch one branch from all remotes
	}
cmd_git_pull(){ 					# gul
	one_remote="$1"
	curr_branch=$(current_branch) #; echo curr_branch: -$curr_branch-
	if [[ "$one_remote" == "" ]]; then # параметр не указан
		curr_remote=$(current_remote)
		# echo -e "{}PUSH to $curr_remote"
		if [[ "$curr_remote" == "" ]]; then 
			#curr_remote=$(cmd_git_remotes_show)
			curr_remote=`git remote show` # если один то сделать его default (upstream)
			err_code=$? && [ "$err_code" != "0" ] && echo "err_code: $err_code"
			cnt=$[$(echo "$curr_remote" | wc -l)]
			[[ $cnt -ne 1 ]] && curr_remote=""
		  fi
		if [[ "$curr_remote" == "" ]]; then
			echo -e "${red}Remote is absent or ambigiouse$norm" 1>&2 
			# return
		  else
			echo -e "[utils-git] ${red}FETCH${norm} $green$curr_remote/$curr_branch$norm"
			# git pull --stat --no-rebase #--all --quiet
			git fetch -vv --quiet "$curr_remote" "$curr_branch" # vv -  отслеживаемые ветки
			err_code=$? && [ "$err_code" != "0" ] && echo "err_code: $err_code"
			
			echo -e "[utils-git] ${red}MERGE${norm} with $green$curr_remote/$curr_branch$norm"  #-u
			git merge "$curr_remote"/"$curr_branch"
			err_code=$? && [ "$err_code" != "0" ] && echo "err_code: $err_code"
			#git branch --set-upstream-to "$curr_remote"/"$curr_branch"
			#git push "$curr_remote" "$curr_branch" -u #all --all
		  fi
	  else
	  	remotes=$(git remote show)
		for next_remote in $remotes; do 
			if [[ "$next_remote" == "$one_remote" || "$one_remote" = "all" ]]; then
				# echo -e "${red}$next_remote$norm"
				echo -e "${yellow}FETCH $next_remote/$curr_branch$norm"  #-u
				#git pull "$next_remote" "$curr_branch"  #all --all
				#echo "fetch"
				git fetch -vv "$next_remote" "$curr_branch"
				err_code=$? && [ "$err_code" != "0" ] && echo "err_code: $err_code"
				#echo "merge"
				
				echo -e "${yellow}MERGE${norm} $curr_branch with $next_remote/$curr_branch$norm"  #-u
				git merge "$next_remote"/"$curr_branch"
				err_code=$? && [ "$err_code" != "0" ] && echo "err_code: $err_code"
				#echo "upstream"
				#git branch --set-upstream-to "$next_remote"/"$curr_branch"
			  #else
			  	#echo $next_remote
			  fi
		  done
	  fi
	}
cmd_git_push(){ 					# gus
	one_remote="$1"
	curr_branch=$(current_branch) #; echo curr_branch: -$curr_branch-
	log_print "one_remote: $one_remote"
	local repo_url
	if [[ "$one_remote" == "" ]]; then # параметр не указан
		curr_remote=$(current_remote)
	  	log_print "push $curr_remote"
		# echo -e "{}PUSH to $curr_remote"
		if [[ "$curr_remote" == "" ]]; then 
			curr_remote=`git remote show` # если один то сделать его default (upstream)
			cnt=$[$(echo "$curr_remote" | wc -l)]
			[[ $cnt -ne 1 ]] && curr_remote=""
		  fi
		if [[ "$curr_remote" == "" ]]; then
			error "Remote is absent or ambigiouse" 1>&2 
			# return
		  else
			notice "PUSH to $curr_remote"  #-u   to ${green}$curr_remote/$green$curr_branch$norm [utils-git] 
			res=`git push "$curr_remote" "$curr_branch" 2>&1` #all --all
			err_code=$? 
			if [ "$err_code" != "0" ]; then 
				error "$res"
			  else
				repo_url=`grep '^To' <<< "$res"`
				if [ "$repo_url" == "" ];then
					result $res
				  else
					result "$repo_url - UPDATED"
				  fi
			  fi
		  fi
	  else
	  	log_print "push all"
	  	remotes=$(git remote show)
		for remote_curr in $remotes; do 
			if [[ "$remote_curr" == "$one_remote" || "$one_remote" = "all" ]]; then
				# echo -e "${red}$name$norm"
				notice "PUSH to $remote_curr"  #-u  to ${green}$name/$green$curr_branch$norm  [utils-git] 
				res=`git push "$remote_curr" "$curr_branch" 2>&1` #all --all
				#if [ $res =~ fatal: http://gitlab.mivar.ru/utils-dt.git/info/refs not valid: is this a git repository?" ]
				# =~ GitLab: The project you were looking for could not be found.\n	fatal: Could not read from remote repository.
				err_code=$?
				if [ "$err_code" != "0" ]; then 
					error "$res"
				  else
					repo_url=`grep '^To' <<< "$res"`
					if [ "$repo_url" == "" ];then
						result $res
					  else
						result "$repo_url - UPDATED"
					  fi
				  fi
				#git branch --set-upstream-to <remote-name>
			  #else
			  	#echo $remote_curr
			  fi
		  done

		# curr_remote=`git remote show | grep $one_remote`
	  fi
	#curr_remote=$(echo "$curr_remote"| perl -pe 's/\\033\[\d*(;\d*)*m//g')
	#echo curr_remote: $curr_remote
	#echo curr_branch: $curr_branch
	}
cmd_git_commit_and_push(){ 				# gok 
	local msg=$1
	local LOCAL
	local BASE
	local REMOTE
	local curr_remote

	# echo -e "BRANCH: $green$(current_branch)$norm"
	savepath=`pwd`
	rootpath=`git rev-parse --show-toplevel`
	cd "$rootpath"
	LOCAL=$(git rev-parse HEAD)
	BASE=`git merge-base @ @{u} 2> /dev/null` 
	curr_remote=`current_remote`

	echo -e -n "\n  Ask ${green}$curr_remote${norm} for last commit .. " 1>&2
	REMOTE=`git ls-remote 2> /dev/null | awk '/HEAD/ {print $1}'` # from remote host

	if [[ "$changes" != "0" ]]; then # append_and_commit
		echo 
		cmd_utils_git_wrapper cmd_git_status_with_untracked
		echo 
		cmd_git_append_and_commit "$msg" 
	  fi
	#git remote | xargs -L1 git push --all --quiet -u
	if [[ "$BASE" != "$REMOTE" || "$BASE" != "$LOCAL" || "$changes" != "0" ]]; then
	  	cmd_utils_git_wrapper cmd_git_push all
	  else
		echo -e -n "\n  ${yellow}Changes not found ${norm}" 
	  fi

	cd "$savepath"
	}

cmd_git_show_file_diff(){ 				# gos
	git show $1
	}
cmd_git_stash_save(){ 					# gst
	git stash #save
	}
cmd_git_stash_list(){ 					# gstl
	git stash list
	}
cmd_git_stash_pop(){ 					# gsp
	git stash pop
	}
